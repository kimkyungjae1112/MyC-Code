# 쓰레드와 관련된 지식 정리

쓰레드를 공부하기 전 컴퓨터 구조, 운영체제를 정리한 문서입니다.

<br>

## 컴퓨터 구조

<br>

### CPU 구성
CPU는 연산장치(Arithmetic Logic Unit), 제어장치(Control Unit), 레지스터(Register) 로 구성되어 있다.
이를 이용해 CPU는 명령어를 읽고 연산을 한다.

<br>

### CPU 동작 과정
CPU는 프로그램의 명령어를 반복적으로 처리하는데, 이 과정을 명령어 사이클(Instruction Cycle)이라고 부른다.
컴퓨터 구조를 수업하신 교수님은 누군가 CPU를 물어보거든 '명령어 사이클'을 처리하는 기계 라고 답하라고 하셨었다. 그만큼 이 부분이 CPU의 정수이지 않나싶다.

<br>

명령어 사이클은 기본적으로 다음 세 단계로 이루어진다.

1. 명령어 인출(Fetch)
    - 프로그램 카운터(PC)에 저장된 다음 명령어의 주소를 메모리 주소 레지스터에 전달한다.
    - 해당 주소의 명령어를 메모리에서 읽어와 메모리 버퍼 레지스터에 저장하고 명령어 레지스터(IR)로 옮긴다.
2. 명령어 해독(Decode)
    - IR에 저장된 면령어를 제어장치가 해석하여, 어떤 연산을 할지 결정하고 필요한 제어 신호를 생성한다.
3. 실행(Execution)
    - 해석된 명령에 따라 ALU가 연산을 수행하거나, 데이터 이동, 입출력 등의 동작을 실행한다.
    - 연산 결과는 다시 레지스터나 메모리에 저장된다.

해당 단계는 CPU의 클럭 신호에 맞춰 매우 빠르게 반복된다.

<br>

리버싱엔지니어링에서 배운 것으로 CPU가 연산을 할 때 dest, src 중 반드시 레지스터가 있어야 한다. 메모리 to 메모리는 한 사이클 내에 처리할 수 없다.

<br>

### 인터럽트(Interrupt) 처리
CPU는 명령어 사이클 중간에 입출력 장치 등에서 예외 상황이 발생하면, 현재 작업 상태를 저장하고 인터럽스 서비스 루틴(ISR, Interrupt Service Routine)을 실행한다.

<br>

인터럽트 처리 단계
1. 인터럽트 발생 : 하드웨어나 소프트웨어가 인터럽트 신호를 CPU에 전달
2. 현재 상태 저장 : CPU는 현재 명령어의 위치(PC)와 레지스터 값을 저장
3. 인터럽트 벡터 확인 : 인터럽트 종류에 따라 ISR 주소를 인터럽트 벡터 테이블에서 조회
4. ISR 실행 : 해당 인터럽트 서비스 루틴으로 분기하여 처리
5. 상태 복원 및 복귀 : ISR 종료 후, 저장해둔 상태를 복원하고 원래 프로그램으로 복귀

<br>

### 명령어 파이프라인(Instruction Pipeline)
CPU의 성능을 높이기 위해 (사실 컴퓨터 과학에서 이 기술이 왜 나왔나? 를 보면 항상 성능을 높이기 위해, 최적화를 위해가 답인 경우가 대부분이다.) 명령어 처리 과정을 여러 단계로 분할하고, 각 단계에서 서로 다른 명령어를 동시에 처리하는 기술이다. 마치 공장 생산 라인처럼, 각 작업 단계가 독립적으로 실행되어 전체 처리 속도를 향상시킨다. 

<br>

명령어 파이프라인은 이번에 쓰레드를 공부하며 가장 밀접한 연관이 있던 부분이었다.
컴파일러와 CPU는 파이프라인을 효율적으로 활용할 수 있도록 명령어를 재배치한다. 
그래서 명령어를 실행 중 Context Switching이 발생했을 때 멀티쓰레딩에서의 불행이 시작된다.

<br>

명령어 파이프라인의 기본 구조와 단계
1. 명령어 인출(Instruction Fetch)
2. 명령어 해독(Instruction Decode)
3. 명령어 실행(Execute)
4. 결과 저장(Writeback)

<br>

하나의 명령어를 실행하고 기다리고, 다른 명령어를 실행하고 기다리고,,,,, 너무 느리다.
명령어 파이프라인은 위 4단계의 작업에서 각각의 작업들을 쉬지 않고 돌린다. 당연히 병렬로 하면 처리 성능은 좋아질텐데 단점은 무엇이 있을까?

<br>

명령어 파이프라인의 한계와 단점
1. 구조적 위험(Structural Hazard)
    - 여러 명령어가 동시에 같은 하드웨어 자원에 접근하려 할 때 발생한다.
2. 데이터 위험(Data Hazard)
    - 한 명령어의 실행 결과가 다음 명령어의 입력으로 필요한데, 결과가 아직 준비되지 않은 상황에서 발생한다.
    - 첫 번째 명령어에서 레지스터 R1에 값을 저장하고, 두 번째 명령어가 바로 R1 값을 사용하려 할 때, 첫 번째명령어의 연산이 끝나지 않았다면 두 번째 명령어는 올바른 값을 참조하지 못함.
3. 제어 위험(Control Hazard)
    - 분기(branch), 점프(jump), 인터럽트 등으로 인해 프로그램 카운터(PC)가 갑자기 변경될 때 발생한다.
    - 분기 명령어가 실행되기 전까지는 다음에 실행할 명령어가 확정되지 않으므로, 파이프라인에 이미 인출된 명령어들이 무효화 될 수 있다.
    - 분기 예측(Branch Prediction) 등으로 완화할 수 있지만, 예측이 빗나가면 파이프라인을 비우고 다시 시작해야 하므로 손실이 크다.

<br>

### 명령어 집합 구조(ISA, Instruction Set Architecture)
CPU가 이해하고 실행할 수 있는 명령어들의 집합을 의미한다. 이는 하드웨어(CPU)와 소프트웨어(프로그램) 사이의 약속이자, CPU의 '언어'라고 할 수 있다. ISA에 따라 명령어의 종류, 형식, 길이, 주소 지정 방식 등이 결정되며, 대표적으로 CISC와 RISC 구조가 있다.

<br>

복잡한 명령어 집합(CISC, Complex Instruction Set Computer)
- 다양한 기능을 수행하는 복잡하고 많은 명령어를 제공하는 CPU 아키텍처이다.
- x86, x86-64 (Intel 계열) 아키텍처 CPU들이 사용한다.
- 주요 특징
    - 가변 길이 명령어
    - 복잡한 명령어
    - 다양한 주소 지정 방식
    - 메모리 직접 연산 지원
    - 명령어의 실행 시간과 크기가 일정하지 않음
- 장점
    - 컴파일러 설계가 쉽다는 장점이 있다.
    - 복잡한 연산을 한 줄의 명령어로 처리할 수 있어, 프로그램 코드가 짧아지고 메모리 사용량이 적어진다.
- 단점
    - 명령어 파이프라이닝에 불리하다.
    - 주요 명령어만 주로 사용되어, 낭비하는 경우가 많다.

<br>

축소 명령어 집합(RISC, Reduced Instruction Set Computer)
- 명령어 집합을 단순화하여 CPU의 하드웨어 구조와 명령어 실행을 효율적으로 만드는 CPU 아키텍처이다.
- ARM 아키텍처 CPU들이 사용한다.
- 주요 특징
    - 단순하고 적은 명령어
    - 고정 길이 명령어
    - 1클럭 내외의 명령어 실행
    - Load/Store 명령어
    - 많은 범용 레지스터
- 장점
    - 파이프라이닝 최적화
    - 명령어 해석이 빠르고 예측이 쉬움
- 단점
    - 프로그램 코드가 길어질 수 있다.
    - 컴파일러 설계가 어려워진다.
    - 레지스터가 많아야 하며, 레지스터 자원이 부족하면 성능 저하가 발생한다.

<br>

### 플린 분류(Flynn's Taxonomy)
컴퓨터가 동시에 처리할 수 있는 명령어 스트림(Instruction Stream)과 데이터 스트림(Data Stream)의 수에 따라 컴퓨터 구조를 분류한다.

<br>

1. SISD(Single Instruction Single Data)
- 한 번에 하나의 명령어, 하나의 데이터만 처리
- 가장 기본적인 구조로, 폰 노이만 구조의 컴퓨터는 이 구조를 따른다.

2. SIMD(Single Instruction Multiple Data)
- 하나의 명령어로 여러 데이터를 동시에 처리
- 최신 컴파일러들은 코드 최적화, 재생성을 통해 SIMD instructionㅇ르 사용한 코드로 변환해주기도 한다.
- 벡터 컴퓨터, GPU

3. MISD(Multiple Instruction Single Data)
- 여러 명령어가 하나의 데이터를 동시에 처리

4. MIMD(Multiple Instruction Multiple Instruction)
- 여러 명령어가 여러 데이터를 동시에 처리
- 멀티 코어 CPU

<br>

## 운영체제

### 프로세스와 쓰레드

프로세스
- 메인 메모리(주기억장치)에 적재되어 실행되는 프로그램을 의미한다.
- 가상 메모리를 사용하며 Code, Data, Heap, Stack 영역으로 나뉜다.
- 프로세스별 각각의 영역을 갖기 때문에 별다른 동기화 작업이 필요하지 않다.
- 프로세스별 각각의 영역을 갖기 때문에 Context Switching 비용이 크다.
- 프로세스 쓰레드보다 무겁기 때문에 생성 시간이 더 길다.
- 한 프로세스에서 오류가 생기더라도 다른 프로세스에 영향을 주지 않는다.
- 프로세스간 통신이 복잡하다.

쓰레드
- 한 프로세스 내의 실행 단위, 실행의 흐름을 의미한다.
- stack 영역만 별도로 갖고, 나머지 영역(code, data, heap)에 대해서는 해당 쓰레드를 포함한 프로세스의 자원을 공유한다.
- stack 영역 외부의 공유 자원에 대해 접근 시 동기화 작업이 필요하다.
- stack 영역 외부를 공유하므로 컨텍스트 스위칭 비용이 적다.
- 쓰레드는 프로세스보다 가볍기 때문에 생성 시간이 더 짧다.
- 한 쓰레드에서 오류가 생기면, 나머지 프로세스 내의 쓰레드에 영향을 줄 수 있다.

<br>

### PCB(Process Control Block), TCB(Thread Control Block)

PCB
- 운영체제가 각 프로세스를 관리하기 위해 생성하는 자료구조로, 프로세스의 상태와 관련된 모든 정보를 저장한다.
- 주요 정보
    - PID(Process ID)
    - 프로세스 상태
    - 프로그램 카운터
    - CPU 레지스터 값
    - 메모리 관련 정보(페이지 테이블)
    - 입출력 상태 정보
    - 스케쥴링 정보(우선 순위, CPU 점유 시간)
    - TCB

TCB
- 쓰레드의 상태와 관리를 위한 자료구조로, 운영체제가 각 쓰레드를 관리하기 위해 생성한다.
- 주요 정보
    - 쓰레드 ID
    - 쓰레드 상태
    - 프로그램 카운터, 레지스터 값, 스택 포인터
    - 우선순위, CPU 사용 시간 등 스케줄링 정보
    - 소속 프로세스의 PCB를 가리키는 포인터
    - 쓰레드가 사용하는 스택의 위치 등